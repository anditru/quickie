\chapter{Programming Principles}
Programming Principles oder zu deutsch Programmierprinzipien sind eine Verallgemeinerung wiederkehrender Erkenntnisse in der Softwareentwicklung und liefern Entwicklern Richtlinien für einen bestimmten Programmierstil. Speziell für die objektorientierte Programmierung existieren die objektorientierten Prinzipien, welche als Idealvorstellung für \enquote{guten} objektorientierten Code dienen. Einige dieser Prinzipien werden in den nachfolgenden Abschnitten vorgestellt und deren Anwendung im vorliegenden Projekt untersucht.

\section{SOLID}
Die SOLID-Prinzipien sind sind eine Sammlung von Regeln mit dem Ziel wartbare und erweiterbare Software mit einer langlebigen Codebasis zu schreiben. Jeder Buchstabe in SOLID steht für den Namen eines einzelnen Prinzips. Im Folgenden wird auf jedes der Prinzipien im Detail eingegangen.

\subsection{Single Responsibility Principle}
Das Single Responsibility Principle besagt, dass jede Klasse nur eine Verantwortlichkeit haben soll. 

Ein Beispiel für eine Klasse, bei der dieses Prinzip verletzt wurde, ist der \code{ProfileService} in der Applikationsschicht, da dieser mehrere Use-Cases umsetzt: Er implementiert die gesamte Interaktion des Nutzers mit einem Profil vom Anlegen, Bearbeiten und Löschen bis zum Setzen und Entfernen von Opinions.

Ein Positivbeispiel für eine Klasse, die das Single Responsibility Principle strikt einhält, ist der \code{Matching Service}, da dieser einzig für das Finden von Rezepten mit hoher Übereinstimmung in den Zutaten zuständig ist. Ebenso verhält es sich mit den Mapperklassen der Adapterschicht: Diese sind lediglich für das Mapping jeweils einer Entity oder eines Value Objects verantwortlich.

Weitere Beispiele für Klassen, welche das Single Responsibility Principle einhalten, sind die Callback-Klassen in der Adapterschicht, da diese jeweils genau einen Use-Case für die Benutzeroberfläche abbilden. So erlaubt beispielsweise der \code{AddProfileCallback} lediglich das Anlegen eines Profiles. Für das Anzeigen und Löschen der Profiles existieren separate Callback-Klassen.

\subsection{Open/Closed Principle}
Das Open/Closed besagt, dass Klassen offen für Erweiterungen, aber geschlossen bezüglich Veränderungen sein sollen. Folglich führen neue oder veränderte Anforderungen nur zu einer Erweiterung des Codes, bestehender Code sollte nicht mehr geändert werden müssen.

Die beiden Klassen \code{ProfileService} und der \code{RecipeService}, die auch das Single Responsibility Principle verletzen, sind auch Negativbeispiele für das Open/Closed Principle: Da diese Klassen jeweils alle Use-Cases implementieren, die Profiles bzw. Recipes betreffen, müssen bei geänderten oder neuen Anforderungen diese beiden bestehenden Klassen verändert werden.

Ein Beispiel für die Einhaltung des Open/Closed Principle Bildet die Adapterschicht: Hier existiert für jeden einzelnen Use-Case eine separate Callback-Klasse, sodass bei neuen Anforderungen lediglich eine neue Callback-Klasse implementiert werden müsste und damit der bestehende Code nur erweitert. Die einzige Änderung an bestehendem Code würde im \code{Controller} stattfinden, da dort neue Events bzw. die zugehörigen Callbacks registriert werden.

\subsection{Liskov Substitution Principle}
Das Liskov Substitution Principle besagt, dass es möglich sein muss, Instanzen von Objekten durch ihre Subtypen zu ersetzen. Problematisch kann es sein, wenn Subtypen eine Spezialisierung des Supertypen sind, also zum Beispiel wenn ein Quadrat als Subtyp eines Rechtecks implementiert wird. In dem vorliegenden Projekt ist keine Vererbungsbeziehung vorhanden, die auf das Liskov Substitution Principle untersucht werden kann, da in keinem Fall von einer eigenen konkreten Klasse geerbt wird, sondern nur von abstrakten Klassen. Es könnten die Klassen \code{MapEventAnswerData} und \code{ListEventAnswerData} auf das Liskov Substitution Principle untersucht werden, jedoch ist es hier trivial, dass das Prinzip eingehalten wird, da die Subtypen keine Funktionalität des Supertypen überschreiben.

\subsection{Interface Segregation Principle}
Das Interface Segregation Principle besagt, dass ein Interface möglichst spezifisch auf einen Klienten zugeschnitten werden sollte. Dieses fördert hohe Kohäsion und das Einhalten des Single Responsibility Principles. Dabei ist ein Grundsatz, dass mehr Interfaces besser seien als ein einziges.

Gute Beispiele für das Einhalten dieses Prinzips finden sich bei dem \code{EventAnswerDataFormatter} und der \code{Datasource}. Beide Interfaces sind mit jeweils nur einer einzigen Methode sehr klientenspezifisch und definieren jeweils nur ihren entsprechenden Nutzen: Von der \code{Datasource} sollen Rezepte erhalten werden und daher wird die Methode \code{getRecipes} vorausgesetzt. Der \code{EventAnswerDataFormatter} soll Objekte formattieren, die das Interface \code{EventAnswerData} implementieren, daher wird die Methode \code{convert} bereitgestellt, welche Objekte in formattierten Text konvertiert. Weitere Beispiele nach gleichem Prinzip sind die \code{PersistentProfileFactory} und \code{PersistentRecipeFactory}. 

Negativbeispiele für das Einhalten des Interface Segregation Principles finden sich bei den Interfaces \code{ProfileRepository} und \code{RecipeRepository}. Diese kombinieren jeweils den lesenden sowie schreibenden Zugriff in einem einzelnen Interface. Diese Interfaces könnten aufgeteilt werden auf jeweils ein Interface für den lesenden und ein anderes Interface für den schreibenden Zugriff. Dadurch muss ein Klient, welcher nur lesenden Zugriff benötigt, keine Abhängigkeiten auf ein Interface haben, welches schreibenden Zugriff hat. Ein Vorteil dessen könnte sein, dass dadurch die Zugriffsverwaltung leichter implementiert werden könnte. In typischen Systemen haben nicht alle Nutzer Schreibrechte, welche Leserechte haben und so könnte eine einfachere nur lesende Implementierung verwendet werden, wenn das Schreiben nicht benötigt wird.

\subsection{Dependency Inversion Principle}
Das Dependency Inversion Principle besagt, dass Details jeweils von Abstraktionen abhängen sollen. Daher werden die Schnittstellen der Implementierungen definiert und dann davon abhängig implementiert. Andere Objekte können dann von der Schnittstelle abhängig sein, ohne von konkreten Implementierungsdetails abzuhängen. Dadurch kann eine Implementierung durch eine andere ausgetauscht werden, solange dieses die gleiche Schnittstelle implementiert. Damit werden die Module voneinander entkoppelt und besser Wiederverwendbar.

Das Dependency Inversion Principle wird hier zum Beispiel bei dem \code{EventCallback} eingahalten. Dieses definiert die allgemeine Schnittstelle aller Reaktionen auf ein bestimmtes Event, während in den Klassen im Package \code{org.} \code{pinkcrazyunicorn.} \code{quickie.} \code{adapters.} \code{callbacks} die konkreten Implementierungen vorhanden sind. Dadurch hat die Benutzeroberfläche in der Klasse \code{CommandLineUI} keine Abhängigkeit auf die konkreten Implementierungen, sondern kriegt diese lediglich durch Aufrufe der Methode \code{registerEvent} übergeben. Ein weiteres Beispiel findet sich bei den Repositories der Entitäten. Diese definieren jeweils alle notwendigen Methoden, die benötigt werden und die Services haben anschließend Abhängigkeiten auf die Interfaces, nicht auf die konkreten Implementierungen der Persistenz. Dadurch kann die Persistenz leicht ausgetauscht werden. Ebenfalls können die Objekte dadurch für Unit Tests durch Mock-Objekte ausgetauscht werden. Dieses wird in den Tests in den Klassen \code{ProfileServiceTest}, \code{RecipeServiceTest} und \code{MatchingServiceTest} dargestellt.

Das Dependency Inversion Principle wird bei den Mapper-Klassen der Adapterschicht nicht eingehalten. Hier hängen die Klassen jeweils von konkreten Instanzen der Mapper ab. Deutlich besser wäre es gewesen, Interfaces für das Mappen von Klassen zu definieren und Implementierungen für das Mapping dieser Objekte. Dadurch wären die Implementierungen stärker entkoppelt und könnten auch in Unit Tests durch Mock-Objekte ausgetauscht werden.

\section{GRASP}
GRASP steht für \enquote{General Responsibility Assignment Software Patterns/Principles}. Hierbei handelt es sich um neun Lösungsschemata für typische Fragestellungen in der Softwareentwicklung. Die Grundlage für GRASP bilden die beiden Prinzipien \enquote{Geringe Kopplung} und \enquote{Hohe Kohäsion}. Diese sollen in den beiden folgenden Abschnitten zuerst erläutert und anschließend aufgezeigt werden, inwiefern diese im vorliegenden Projekt zur Anwendung kamen.

\subsection{Geringe Kopplung}
Mit Kopplung wird in diesem Zusammenhang ein Maß für die Abhängigkeit einer Klasse von ihrer Umgebung bezeichnet. Das Ziel ist es, Code mit möglichst geringer Kopplung zu schreiben. Im vorliegenden Projekt wurde auf eine besonders geringe Kopplung zwischen der Applikationsschicht und Benutzeroberfläche Wert gelegt: Hier wird die geringste Stufe der Kopplung verwendet, bei der sich die beteiligten Kommunikationspartner nicht mehr kennen, nämlich eine rein eventbasierte Kommunikation durch die Adapterschicht. Auf diese Weise können auf möglichst einfache Weise weitere Schnittstellen, wie zum Beispiel ein HTTP-Interface, hinzugefügt werden.

Ein Beispiel für etwas stärkere Kopplung als bei der eventbasierten Kommunikation findet sich in den Serviceklassen der Adapterschicht. Müssen hier Daten persistiert werden, werden lediglich Methoden der im Domaincode definierten Interfaces für die Repositories aufgerufen und so eine direkte Kopplung an eine bestimmte Implementierung eines Repositories vermieden.

Ein Beispiel für starke Kopplung befindet sich in den Mapperklassen der Adapterschicht: Der \code{ProfileMapper} ist durch statische Methodenaufrufe stark an den \code{FoodMapper} und den \code{OpinionMapper} gekoppelt. Darüber hinaus werden der \code{FoodMapper} und der \code{OpinionMapper} auch nicht injected, sondern direkt im Konstruktor instanziiert, was die Kopplung zusätzlich erhöht.

\subsection{Hohe Kohäsion}
Die Kohäsion ist ein Maß für den inneren Zusammenhalt einer Klasse, zeigt also wie eng die Methoden und Attribute einer Klasse zusammenarbeiten. Ziel ist es, Klassen mit möglichst hoher Kohäsion zu schreiben.

Negativbeispiele, bei denen die Kohäsion in den Klassen gering ist, sind der \code{ProfileService} und der \code{RecipeService} in der Applikationsschicht. Hier betreffen die Methoden einer Klasse zwar nur eine Entity, allerdings implementieren die Methoden jeweils völlig unabhängige Use Cases, welche dennoch alle in einer Klasse zusammengefasst sind.

Beim dritten Service der Applikationsschicht, dem \code{MatchingService}, ist die Kohäsion hingegen hoch, da dieser lediglich einen einzigen Use-Case behandelt, nämlich das Finden ähnlicher Rezepte. Daher besitzt diese Klasse auch nur die öffentliche Methode \code{getMatchingRecipesFor}. Alle anderen Methoden sind privat und beinhalten Teilschritte des Matchingvorgangs.

Ein weiteres Beispiel für Klassen mit hoher Kohäsion sind die Mapperklassen der Adapterschicht, da sich jede der Klassen nur mit dem Mapping einer einzigen Entity bzw. eines Value Objects in verschiedene Formate befasst. Darüber hinaus befasst sich jede dieser Klassen nur mit einem einzigen Use-Case, dem Mapping. Damit gehören auch hier die Methoden einer Klasse semantisch zusammen.

\section{DRY}
DRY steht für \enquote{Don't Repeat Yourself} und ist der Name eines Programmierprinzips, welches besagt, dass redundanter Code vermieden werden sollte. Grund dafür ist, dass dadurch Wissen zentral festgehalten wird. Sollte das festgehaltene Wissen verändert werden müssen, so muss dieses folglich auch nur an einer Stelle geändert werden. Im Folgenden sollen Code-Beispiele diskutiert werden, welche Positiv- und Negativbeispiele für die Anwendung des DRY-Prinzips darstellen.

Ein Beispiel für das Einhalten des DRY-Prinzips ist in der Verifizierung der Parameter eines Callbacks zu sehen. Hier wird zentral in jeder Callback-Klasse durch die Methode \code{getRequiredParameters} definiert, welche Parameter benötigt werden. Das CLI Plugin nutzt diese Informationen, um die übergebenen Parameter in der Methode \code{ensureRequiredParameters} auf Vollständigkeit für den entsprechenden Callback zu prüfen sowie um die Benutzerhilfe in \code{constructOptions} zu generieren.

Ein Negativbeispiel für das Nichteinhalten des DRY-Prinzips ist in der Implementierung der zu persistierenden Entitäten zu sehen. Diese werden einmal zentral in der Domäne definiert, während es dann jedoch in der Adapterschicht noch die Interfaces \code{PersistentProfile} und \code{PersistentRecipe} gibt, welche durch Getter- und Setter-Methoden die notwendigen und zu persistierenden Eigenschaften der Entitäten definieren. Diese werden abschließend im \code{persistence} Plugin implementiert. Dadurch wird die Struktur einer Entität einmal in der Domäne und einmal in der Persistenz definiert, es gibt eine Dopplung der Informationen, welche Attribute zu einer Entität gehören. Diese Verletzung des DRY-Prinzips wurde begangen, um die Persistenz-Darstellung von der Arbeitsdarstellung zu entkoppeln, wodurch die Persistenz deutlich flexibler gestaltet werden kann.

Ein weiteres simpleres Negativbeispiel findet sich in Methoden des \code{JPAProfileRepository} und \code{JPARecipeRepository}. In diesen wird, falls ein \code{PersistentReicipe} oder \code{PersistentProfile} übergeben wird, immer zunächst geprüft, ob dieses eine Instanz eines \code{JPARecipe} beziehungsweise \code{JPAProfile} ist. Diese Überprüfung hätte in eine eigene Methode ausgelagert werden können, um Flüchtigkeitsfehler durch die Redundanz des Codes zu verhindern und die Wartung zu erleichtern.

Ein Beispiel für eine solche ausgelagerte Methode findet sich in der Klasse \code{CommandLineUI} mit der Methode \code{printHelp}. Diese Methode definiert zentral, wie die Hilfe ausgegeben werden soll und erfüllt somit das DRY-Prinzip.
