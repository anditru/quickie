\chapter{Clean Architecture}
In diesem Kapitel wird die Architektur der entwickelten Software beschrieben. Diese wurde nach den in der Vorlesung besprochenen Prinzipien der Clean Architecture aufgebaut. Jeder der nachfolgenden Abschnitte behandelt eine Schicht. Die Schichten 1, 2 und 3 sind jeweils als ein eigenes Java-Module implementiert. Lediglich Schicht 0, welche die Plugins und das Main-Module mit der Main-Klasse der Applikation enthält, bildet eine Ausnahme: Hier entspricht jedem Plugin sowie dem Main-Module ein separates Java-Module, da diese komplett und leicht austauschbar sein sollen.

Die Clean Architecture hält neben den vier für dieses Projekt verwendeten Schichten noch eine fünfte bereit, den Abstraction Code. Auf diese Schicht, wurde für dieses Projekt jedoch verzichtet, da für die in der Domäne behandelten Themengebiete \enquote{Kochrezepte} und \enquote{Lebensmittel} kein domänenübergreifendes Wissen notwendig war, welches Teil dieser Schicht hätte sein müssen. 

\section{Schicht 3: Domain}
Diese Schicht befindet sich im Module \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/3-quickie-domain}{\code{3-quickie-domain}} und enthält die in \autoref{fig:class-diag-domain} dargestellten Klassen und Interfaces. Die enthaltenen Klassen implementieren die Entities und Value Objects der Domäne der Software, welche die Enterprise Business Logik der Software abbilden und damit die typischen Elemente des Domain Codes darstellen. Die enthaltenen Interfaces geben die notwendigen Methoden für die zugehörigen Repositories vor, welche gemäß der in der Vorlesung besprochenen Clean Architecture ebenfalls Teil des Domain Codes sind.

Der Code dieser Schicht bedient sich lediglich des Java-Standards und ist damit als zentrale und langlebigste Schicht der Software frei von jeglichen Abhängigkeiten.

\section{Schicht 2: Application}
Diese Schicht befindet sich im Module \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/2-quickie-application}{\code{2-quickie-application}} und implementiert die eingangs beschriebenen Anwendungsfälle. Diese sind in den drei Services \code{ProfileService}, \code{MatchingService} und \code{RecipeService} gruppiert. Diese sind in \autoref{fig:class-diag-application} als Klassendiagramme dargestellt.

\begin{figure}[ht!]
    \includegraphics[width=0.98\columnwidth]{../diagrams/application_uml.pdf}
    \caption{Klassendiagramm der Applikationsschicht}
    \label{fig:class-diag-application}
\end{figure}

Die einzige Abhängigkeit des Modules besteht dabei auf den Domaincode der Software. Eine Abhängigkeit auf die Datenquelle, welche die Kochrezepte liefert wurde durch eine Dependency Inversion vermeiden, indem hier das Interface \href{https://github.com/anditru/quickie/blob/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/2-quickie-application/src/main/java/org/pinkcrazyunicorn/quickie/application/recipe/Datasource.java}{\code{Datasource}} definiert wird, welches von allen Datenquellen implementiert werden muss. Somit besitzt jede Datenquelle eine Abhängigkeit auf die Adapterschicht, nämlich auf das Interface \href{https://github.com/anditru/quickie/blob/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/2-quickie-application/src/main/java/org/pinkcrazyunicorn/quickie/application/recipe/Datasource.java}{\code{Datasource}}. Umgekehrt erwartet aber der \href{https://github.com/anditru/quickie/blob/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/2-quickie-application/src/main/java/org/pinkcrazyunicorn/quickie/application/recipe/RecipeService.java}{\code{RecipeService}} lediglich eine Klasse, welche dieses Interface implementiert und besitzt somit keine Abhängigkeit auf eine spezielle Implementierung.

\section{Schicht 1: Adapters}
Die Adapterschicht wurde im Module \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters}{\code{1-quickie-adapters}} implementiert und erfüllt in der zugrundeliegenden Software zwei Aufgaben: Zum einen werden die Daten durch Mapper-Klassen von dem Format, welches die Services aus der Applikationsschicht liefern, in das Format übersetzt, welches die Plugins benötigen und umgekehrt. Zum anderen regelt sie die Kommunikation zwischen den Plugins und der Applikationsschicht. Um hierbei eine möglichst große Entkopplung zwischen den Plugins und der Applikationsschicht zu erreichen, geschieht diese Kommunikation eventbasiert.

\begin{figure}[ht!]
    \includegraphics[width=0.98\columnwidth]{../diagrams/adapter_uml.pdf}
    \caption{Vereinfachter Ausschnitt des Klassendiagramms der Adapterschicht}
    \label{fig:class-diag-adapter}
\end{figure}

\autoref{fig:class-diag-adapter} zeigt einen Ausschnitt des Klassendiagramms der Adapterschicht in vereinfachter Form. Die Adapterschicht besitzt vier Packages: \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/callbacks}{\code{callbacks}}, \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/event}{\code{event}}, \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/mappers}{\code{mappers}} und \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/persistence}{\code{persistence}}. Letzteres wurde hier im Sinne der Übersichtlichkeit zunächst nicht dargestellt.

Das Package \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/event}{\code{event}} enthält Pure Fabrication Code, welcher ausschließlich die eventbasierte Kommunikation betrifft. Die Klasse \code{Event} repräsentiert hierbei ein Event, welches von der Benutzeroberfläche gesendet wird und besitzt einen \code{EventType}. Die Klasse \code{EventAnswer} bildet das Resultat der Verarbeitung eines Events ab, welches an die Benutzeroberfläche zurückgeschickt wird. Die Daten, welche mittels der \code{EventAnswer} an die Benutzeroberfläche geschickt werden, werden in einem separaten Objekt gehalten. Hierbei handelt es sich je nach Form der Daten um eine Instanz einer Klasse, welche das Interface \code{EventAnswerData} implementiert. Die Logik, welche beim Auftreten eines bestimmten Events aufgerufen wird, befindet sich in Callback-Klassen. Zu jedem \code{EventType} existiert eine entsprechende Callback-Klasse, welche das Interface \code{EventCallback} implementiert. Diese Callback-Klassen werden im Package \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/callbacks}{\code{callbacks}} implementiert.

Das Package \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/mappers}{\code{mappers}} enthält die Mapperklassen, welche die von der Applikationsschicht gelieferten Daten in das von der Benutzeroberfläche benötigte Format transformiert.

Das zentrale Element der Adapterschicht ist der \href{https://github.com/anditru/quickie/blob/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/Controller.java}{\code{Controller}}. Dieser registriert beim Start der Applikation zunächst für jeden \code{EventType} die zugehörige Callback-Klasse bei der Benutzeroberfläche, welche das Interface \code{UI} implementieren muss. Er bildet außerdem den Einstiegspunkt bei der Verarbeitung eines Events von der Benutzeroberfläche, indem er das aufgetretene Event von der Benutzeroberfläche abfragt und dessen Verarbeitung durch den Aufruf der Methode \code{handleEvent} in Gang setzt.

\begin{figure}[ht!]
    \includegraphics[width=0.98\columnwidth]{../diagrams/adapter_sequence.pdf}
    \caption{Verarbeitung eines User-Events}
    \label{fig:squence-diag-adapter}
\end{figure}

\autoref{fig:squence-diag-adapter} zeigt beispielhaft den Ablauf bei der Verarbeitung eines Events vom Typ \code{viewRecipes}. Die beteiligten Objekte sind hier farblich nach ihrer Schichtzugehörigkeit markiert: Grün steht für die Adapterschicht, Blau für die Applikationsschicht und Rot für ein Plugin.

Das Package \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/persistence}{\code{persistence}} bildet die Schnittstelle zwischen der Applikationsschicht und Plugins für die Persistenz. Hier werden Interfaces definiert, welche die zu persistierenden Klassen implementieren müssen, nämlich \code{PersistentProfile}, \code{PersistentRecipe} und \code{PersistentIngredient}. Außerdem werden die Mapper-Klassen \code{PersistentProfileMapper} und \code{PersistenRecipeMapper} implementiert, welche die Domänenobjekte in ihre persistenten Gegenstücke transformieren und umgekehrt. Ferner werden in dem Package die Interfaces \code{PersistentProfileFactory} und \code{PersistentRecipeFactory} definiert, welche dann im Persistenz-Plugin implementiert werden und in den Mapper-Klassen verwendet werden, um leere \code{PersistentProfile}s und \code{PersistentRecipe}s zu erzeugen. Zuletzt werden hier auch die beiden im Domaincode definierten Interfaces \code{RecipeRepository} und \code{ProfileRepository} in den beiden abstrakten Klassen \code{PersitentRecipeRepository} und \code{PersistentProfileRepository} implementiert, von welchen dann die Repositories in einem Persistenz-Plugin erben.

\section{Schicht 0: Plugins}
Bei Schicht 0 handelt es sich um die äußerste Schicht des Projekts, in der sämtliche Plugins angesiedelt sind. Diese enthalten neben der Main-Komponente alle Funktionen, welche leicht austauschbar sein sollten, wie die Benutzeroberfläche oder die Persistenz. Außerdem werden sie meist mit der Unterstützung externer Libraries realisiert, besitzen also Abhängigkeiten, welche in der Schichtenhierarchie möglichst weit nach außen verschoben werden sollten.

\subsection{Plugin \acs{CLI}}
Dieses Plugin, welches im Module \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/0-quickie-plugin-cli}{\code{0-quickie-plugin-cli}} implementiert wurde und die Benutzeroberfläche der Software bildet, enthält lediglich die Klasse \code{CommandLineUI}. Diese implementiert das Interface \code{UI} aus der Adapterschicht.

Durch dieses Interface wird eine Abhängigkeit der Adapterschicht auf das Plugin nach dem Prinzip der Dependency Inversion vermieden. Die Adapterschicht definiert statt dessen das Interface \href{https://github.com/anditru/quickie/blob/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/UI.java}{\code{UI}}, welches im Plugin implementiert werden muss, damit es von der Adapterschicht verwendet werden kann. Damit besitzt nun das Plugin eine Abhängigkeit auf die Adapterschicht, nämlich auf das Interface \href{https://github.com/anditru/quickie/blob/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/UI.java}{\code{UI}}. 

Abgesehen von dieser besitzt dieses Plugin nur eine weitere Abhängigkeit: Die Library Apache Commons CLI, welche zur leichteren Implementierung der \ac{CLI} verwendet wird. Das Plugin kommuniziert lediglich über die Eventfunktionalität der Adapterschicht mit dem Kern der Software, ist damit nur sehr lose an den selben gekoppelt und kann leicht ausgetauscht werden.

\subsection{Plugin Gson}
Dieses Plugin, welches im Module \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/0-quickie-plugin-gson}{\code{0-quickie-plugin-gson}} implementiert wurde, realisiert Formatierung der in der Kommandozeile auszugebenden Daten in das JSON-Format. Da es zu diesem Zweck sinnvoll ist, eine Library wie Gson zu verwenden, wurde diese Funktionalität in ein Plugin ausgelagert. Um eine Abhängigkeit des Plugins \acs{CLI} auf dieses zu vermeiden, erwartet das \ac{CLI} als Formatter eine Klasse, welche das in der Adapterschicht definierte Interface \code{EventAnswerDataFormatter} implementiert. In diesem Plugin geschieht dies durch die Klasse \code{GSONFormatter}.

\subsection{Plugin JPA}
Dieses Plugin wurde im Module \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/0-quickie-plugin-jpa}{\code{0-quickie-plugin-jpa}} implementiert und realisiert die Persistenz der Software mit Hilfe der \ac{JPA} und deren Implementierung Hibernate. Auch dieses Plugin besitzt nur eine Abhängigkeit auf die Adapterschicht, da hier im Package \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/1-quickie-adapters/src/main/java/org/pinkcrazyunicorn/quickie/adapters/persistence}{\code{persistence}} definierten Interfaces für Factories und die zu persistierenden Objekte Recipe, Ingredient und Profile implementiert werden. Letztere enthalten außerdem die \ac{JPA}-Annotationen. Ferner enthält das Plugin die Klassen \code{JPARecipeRepository} und \code{JPAProfileRepository}, welche von den beiden abstrakten Repository-Klassen aus der Adapterschicht erben. Schließlich enthält das Plugin noch den \code{PersistenceMananger}, einen Singleton, welcher den \code{EntityManager} von \code{JPA} für die Repositories liefert.

\subsection{Plugin Scraper}
In diesem Plugin wird die Extraktion der Rezepte aus den entsprechenden Webseiten im Module \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/0-quickie-plugin-scraper}{\code{0-quickie-plugin-scraper}} implementiert. Hierzu werden die Webseiten zunächst durch den \code{CachedDownloader} heruntergeladen. Für das Parsen der Webseiten wird der \code{HensslerScraper} verwendet, welcher die Rezeptdaten aus dem HTML-Text extrahiert. Diese werden dann durch die \code{HensslerDatasource}, welche das in der Applikationsschicht definierte Interface \code{Datasource} implementiert, für die Applikationsschicht zugänglich gemacht. Die Daten durchlaufen damit nicht die Adapterschicht, da der Scraper die Daten problemlos direkt in dem von der Applikationsschicht benötigten Format liefern kann.

Untypisch an diesem Plugin ist sein relativ großer Umfang und die große Menge an Logik, die in dem Plugin vorhanden ist, um die Webseiten zu parsen. Folglich wäre es auch denkbar gewesen, die entsprechende Logik in Schicht 2, der Applikationsschicht, zu implementieren. Da es jedoch nicht Teil unserer Use-Cases ist, speziell Hensslers Webseiten zu parsen, sondern lediglich die Einbindung von verschiedenen Datenquellen für Rezepte zu ermöglichen, wird das Parsen selbst nicht als Teil der Applikationsschicht gesehen. Außerdem kann sich die Struktur einer Webseite leicht ändern, was zwangsweise auch Änderungen an dem Scraper nach sich ziehen würde. Auch um solch häufige Änderungen von der Applikationsschicht fernzuhalten, wurde diese Funktionalität in ein Plugin ausgelagert.

\subsection{Plugin Main}
Die Main-Komponente der Software wurde im Module \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33/0-quickie-plugin-main}{\code{0-quickie-plugin-main}} implementiert und enthält lediglich die Main-Klasse der Applikation, welche alle nötigen Klassen instanziiert und ggf. injected. Zuletzt wird hier auch die Methode \code{run} des Controllers aus der Adapterschicht ausgeführt und somit die Verarbeitung von Events gestartet. Dieses Module besitzt folglich Abhängigkeiten auf alle anderen Modules der Software und befindet sich daher in der äußersten Schicht.

Gemäß Robert C. Martins Festlegung in \cite{Martin.2018}, wird auch hier die Main-Komponente als Plugin betrachtet, obwohl sie Abhängigkeiten auf andere Plugins besitzt und somit als in einer weiter außen liegenden Schicht aufgefasst werden könnte.
