\chapter{Refactoring}
Refactoring bezeichnet in der Softwareentwicklung Änderungen an den Interna einer Software, um diese verständlicher und änderbarer zu gestalten, ohne ihr sichtbares Verhalten zu ändern. Auch im Zuge dieses Projekts entstanden während der Entwicklung sogenannte Code Smells, also verbesserungswürdige Stellen im Code. Drei dieser Code Smells werden in den nachfolgenden Abschnitten beschrieben und anschließend gezeigt, wie diese durch Refactoring korrigiert wurden. Alle drei dieser Code Smells sind auf dem Stand des Commits \href{https://github.com/anditru/quickie/tree/bb41442c7f1ffbfcd3117cd86a40f7932e543a33}{bb41442c7f1ffbfcd3117cd86a40f7932e543a33} sichtbar.

\section{Falsch implementierter Singleton}
Für die Persistenz der Software wird \ac{JPA} verwendet. \ac{JPA} arbeitet mit sogenannten \code{EntityManager}n, welche den Zugriff auf Datenbankentitäten kapseln. Erzeugt werden diese \code{EntityManager} durch eine \code{EntityManagerFactory}. Da es sich bei dieser um ein relativ großes Objekt handelt, wurde mit der Klasse \code{PersistenceManager} ein lazy Singleton implementiert, welcher sicherstellen sollte, dass stets nur eine \code{EntityManagerFactory} existiert. Allerdings ist die gewählte Implementierung des Singleton nicht threadsicher und stellt in Java auch nicht vollständig sicher, dass nur eine Instanz der \code{PersistenceManagerFactory} existiert.

Aus diesen Gründen wurde beim Refactoring die Klasse \code{PersistenceManager} komplett entfernt und der Singleton statt dessen \enquote{implizit} umgesetzt, in dem in der Main-Klasse des Programms eine Instanz der \code{EntityManagerFactory} zentral erzeugt wird, welche dann in die Repositories injected wird. Diese Variante implementiert das Entwurfsmuster Singleton zwar nicht explizit, stellt jedoch tatsächlich sicher, dass nur eine Instanz der \code{EntityManagerFactory} existiert und ist außerdem threadsicher. Dieses Refactoring kann im Commit \href{https://github.com/anditru/quickie/commit/ab3ffd3a597ec6aee30ace0f75c9ace79617804e}{ab3ffd3a597ec6aee30ace0f75c9ace79617804e} eingesehen werden.

\section{Doppelt vorhandener Code}
Die Klasse \code{JPAProfileRepository} implementiert unter anderem die Methoden \code{persistentAdd}, \code{persistentUpdate} und \code{persistentRemove} zur Erstellung, Änderung und Löschung von Profiles. Da diese Methoden von der abstrakten Klasse \code{PersistentProfileRepository} geerbt werden, erwarten diese als Argument ein \code{PersistentProfile}. Die konkrete Implementierung \code{JPAProfileRepository} kann jedoch nur Profiles vom Typ \code{JPAProfile}, einer Unterklasse des \code{PersistentRecipe}, verarbeiten. Darum muss zu Beginn der Methoden geprüft werden, ob das übergebene Profile den passenden Typ besitzt, sonst wird eine Exception geworfen.

Der hierfür zuständige Code ist in allen drei Methoden identisch, wurde jedoch explizit in jeder der Methoden ausgeschrieben. Hierbei handelt es sich eindeutig um Duplicated Code, einen sehr kritischen Code Smell, der dazu führen würde, dass bei einer Änderung in den Anforderungen an das \code{JPAProfileRepository} die Änderungen ggf. an drei Stellen durchgeführt werden müssten. Aus diesem Grund wurde hier das Refactoring \enquote{Extract Method} angewendet und somit die Überprüfung des Typs in die Methode \code{assertInstanceOfJPARecipe} ausgelagert. Um die Struktur der Repositories im JPA-Plugin konsistent zu halten, wurde die entsprechende Typüberprüfung im \code{JPARecipeRepository} ebenfalls in eine separate Methode ausgelagert, obwohl sie hier nur einmal auftritt. Dieses Refactoring kann im Commit \href{https://github.com/anditru/quickie/commit/00a028943c4e6a02b5ad6f14f0268f60c9528e8f}{00a028943c4e6a02b5ad6f14f0268f60c9528e8f} eingesehen werden.

\section{\code{null} als Rückgabewert}
In der Klasse \code{HensslerScraper} werden die Webseiten mit den einzelnen Rezepten geparsed. Einige Methoden der Klasse liefern unter Umständen \code{null} als Rückgabewert, wenn das gesamte Rezept bzw. ein einzelner Abschnitt eines Rezepts nicht geparsed werden kann. Zwar werden diese Fälle durch entsprechende Überprüfungen abgefangen, dennoch wird auf diese Weise nicht der Fehlerfall vom Normalfall getrennt. Außerdem kann das Abprüfen eines solchen Fehlerfalls leicht vergessen werden.

Aus diesem Grund wurde hier das Refactoring \enquote{Replace Error Code with Exception} angewendet. Statt \code{null} zurückzugeben wird an den entsprechenden Stellen nun die Exception \code{FailedToParseRecipe} bzw. \code{FailedToParseIngredient} geworfen. Auf diese Weise wird sichergestellt, dass die Methoden niemals \code{null} zurückgeben, außerdem werden Entwickler durch den Compiler gezwungen, die beiden Fehlerfälle zu behandeln. Dieses Refactoring kann im Commit \href{https://github.com/anditru/quickie/commit/301bc8fba7e86b8386e09629ab2178e0258b7e78}{301bc8fba7e86b8386e09629ab2178e0258b7e78} eingesehen werden.
